Group: Ben Teichler, Charles Sharp,  Jack Nickel


Part 1 Findings:
There is little control when using for loops; it implicitly moves to the next object in the list.


Part 2 Findings:
There is much more control with iterators than with for loops. You can manually move on to the next object and pause whenever.


Part 3 Findings:
We found that the function runs until it reaches a yield statement, which pauses the function. You can keep using next().


Part 4 Findings:
We found that yield pauses a function and can pick up where it left off, whereas return kills it.


Part 5 Findings:
We found that local variables are not reset when yielding.


Part 6 Findings:
Each time we use next(), the for loop in the function runs to completion until it reaches a yield, then resumes from where it left off.


Part 7.1 Findings:
We found out what the __str__ and __repr__ dunder methods do. The __repr__ represents information about the class and __str__ is a string representing the function.


Part 7.2 Findings:
We found that __bool__ and __len__ can attach values to the entire class instance.


Part 7.3 Findings:
We found that __getitem__ is for accessing objects like lists and dictionaries.


Part 7.4 Findings:
We used __eq__, __lt__, and __add__ allow you to use class instances for operations like adding and such.


Part 8 Findings:
Generators are objects that already implement __iter__ and __next__, like it just does it.


After discussing after the lab, we discovered that classes and dunder methods are stored in the heap and not the stack.










Closures and Decorators Portion


1.1 - Simple Closure
* x is stored locally in the function; it is stored in the heap.
* x still exists because it is stored in a closure cell in the heap.
* Execution does restart each call.


1.2 - Closure with changing state
* count doesn’t reset to 0 because it is stored in the heap, despite the stack frame being destroyed and created multiple times.
* After counter() returns, count lives in the heap. Closure stores data, not execution state.


1.3 - Prove where the data lives
* The stack frame is gone, and the value is stored inside the function object.


2.1 - Basic Decorator - Basic Decorator (Wrapper in Action)
* The my_decorator() function runs first
* We did not modify greet()
* The decorator before the function greet() added the extra behavior with the wrapper controlling execution


2.2 - Decorator vs Wrapper
* The decorator runs once at definition time because the wrapper is called.
* The wrapper runs every time the function is called because it is inside the function.
* The original function runs only if the wrapper calls it because it is what modifies the function.


2.3 - Inspect the Decorator Function
* The function name refers to the decorator because the decorator is reassigned, changing what the function points to. 
* The original function is stored in the wrapper’s closure because we are not directly calling the function, since we reassigned the function name to the wrapper, but the function still has to be stored in order to be called.


3 - Decorator with Arguments
* Logging is added before the function is executed
* Add did not change
* Using *args collects the arguments into a touple that is then used in the wrapper


4.1 - Closure = Memory Data
* Stores data. No wrapper. No behavior interception.


4.2 - Decorator = Behavior Wrapping
* Extra behavior added. Wrapper layer present. Original function untouched.


Final Rule: Final Rule: Closures store data. Decorators configure behavior. Wrappers execute behavior.


Question                 Closure                 Decorator
Stores data?            Yes                      Yes
Adds wrapper?      No                      Yes
Changes original 
function code?              No                    No
Execution 
restarts?             Yes                   Yes